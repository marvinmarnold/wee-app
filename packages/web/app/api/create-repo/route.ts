import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { execSync, ExecException } from 'child_process';

// Helper function copyDirRecursiveSync removed

// Define a type for the Vercel deployment trigger body if specific fields are known,
// otherwise, leave as a broader type if structure is very dynamic or less critical for strong typing here.
interface VercelTriggerDeploymentBody {
    name: string;
    gitSource: {
        type: string;
        repoId: number; // Assuming repoData.id is a number from GitHub API
        ref: string;
    };
    target: string;
}

export async function POST() {
    const { GITHUB_TOKEN, GITHUB_USERNAME, VERCEL_TOKEN, VERCEL_TEAM_ID } = process.env;

    if (!GITHUB_TOKEN || !GITHUB_USERNAME) {
        return NextResponse.json(
            { error: 'GitHub token or username not configured.' },
            { status: 500 }
        );
    }
    if (!VERCEL_TOKEN) {
        return NextResponse.json(
            { error: 'Vercel token not configured.' },
            { status: 500 }
        );
    }

    const repoNameBase = `miniapp`;
    const repoName = `${repoNameBase}-${Date.now()}`;

    try {
        const createRepoResponse = await fetch('https://api.github.com/user/repos', {
            method: 'POST',
            headers: {
                Authorization: `token ${GITHUB_TOKEN}`,
                Accept: 'application/vnd.github.v3+json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                name: repoName,
                private: false,
                description: 'A new miniapp generated by WeeApp',
            }),
        });

        if (!createRepoResponse.ok) {
            const errorData = await createRepoResponse.json();
            console.error('GitHub API Error (Create Repo):', errorData);
            return NextResponse.json(
                { error: `Failed to create GitHub repository: ${errorData.message || createRepoResponse.statusText}` },
                { status: createRepoResponse.status }
            );
        }

        const repoData = await createRepoResponse.json() as { id: number; name: string; html_url: string; ssh_url: string; clone_url: string };

        const templatePath = path.resolve(process.cwd(), '_app_template');
        const tempBaseDir = path.join('/tmp', 'weeapp-processing');
        const tempRepoPath = path.join(tempBaseDir, repoData.name);

        try {
            if (!fs.existsSync(tempBaseDir)) {
                fs.mkdirSync(tempBaseDir, { recursive: true });
            }
            if (fs.existsSync(tempRepoPath)) {
                fs.rmSync(tempRepoPath, { recursive: true, force: true });
            }
            fs.mkdirSync(tempRepoPath, { recursive: true });

            console.log(`Copying template from ${templatePath} to ${tempRepoPath} using cp -a...`);
            // 4. Copy template files using cp -a
            execSync(`cp -a "${templatePath}/." "${tempRepoPath}/"`, { stdio: 'pipe' });

            console.log('Listing contents of tempRepoPath after cp -a:');
            try {
                const filesInTemp = execSync('ls -la', { cwd: tempRepoPath, stdio: 'pipe' }).toString();
                console.log(filesInTemp);
            } catch (lsError: unknown) {
                console.error('Error listing files in tempRepoPath:', (lsError as Error).message);
            }

            const templateGitignorePath = path.join(tempRepoPath, '.gitignore');
            if (fs.existsSync(templateGitignorePath)) {
                try {
                    const gitignoreContent = fs.readFileSync(templateGitignorePath, 'utf8');
                    console.log('Content of .gitignore in template:');
                    console.log(gitignoreContent);
                } catch (readError: unknown) {
                    console.error('Error reading .gitignore in template:', (readError as Error).message);
                }
            } else {
                console.log('No .gitignore file found at the root of the copied template.');
            }

            const templateGitDir = path.join(tempRepoPath, '.git');
            if (fs.existsSync(templateGitDir)) {
                fs.rmSync(templateGitDir, { recursive: true, force: true });
            }

            const gitUserEmail = `${GITHUB_USERNAME}@users.noreply.github.com`;
            const remoteUrl = `https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com/${GITHUB_USERNAME}/${repoData.name}.git`;

            const execOptions = {
                cwd: tempRepoPath,
                stdio: 'pipe' as const,
                env: {
                    ...process.env,
                    GIT_AUTHOR_NAME: GITHUB_USERNAME,
                    GIT_AUTHOR_EMAIL: gitUserEmail,
                    GIT_COMMITTER_NAME: GITHUB_USERNAME,
                    GIT_COMMITTER_EMAIL: gitUserEmail,
                }
            };

            console.log(`Initializing Git repository in ${tempRepoPath}`);
            execSync('git init -b main', execOptions);

            console.log('Adding files to Git...');
            execSync('git add .', execOptions);

            console.log('Checking git status...');
            const statusOutput = execSync('git status --porcelain', execOptions).toString().trim();
            let commitMade = false;

            if (!statusOutput) {
                console.warn('No changes to commit. Template might be empty or all files are gitignored. Repository will be created empty.');
            } else {
                console.log('Committing files...');
                execSync('git commit -m "Initial commit: Farcaster miniapp template by WeeApp"', execOptions);
                commitMade = true;
            }

            if (commitMade) {
                console.log(`Adding remote origin: ${repoData.html_url}`);
                execSync(`git remote add origin ${remoteUrl}`, execOptions);
                console.log('Pushing to GitHub...');
                execSync('git push -u origin main', execOptions);
            } else {
                console.log('Skipping push as no commits were made.');
            }

            // GitHub operations successful, proceed to Vercel
            let vercelProjectUrl = '';
            try {
                console.log(`Creating Vercel project for GitHub repo: ${GITHUB_USERNAME}/${repoData.name}`);
                const vercelApiProjectsUrl = VERCEL_TEAM_ID
                    ? `https://api.vercel.com/v10/projects?teamId=${VERCEL_TEAM_ID}`
                    : 'https://api.vercel.com/v10/projects';

                const vercelProjectResponse = await fetch(vercelApiProjectsUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${VERCEL_TOKEN}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: repoData.name,
                        framework: 'nextjs',
                        gitRepository: {
                            type: 'github',
                            repo: `${GITHUB_USERNAME}/${repoData.name}`,
                        },
                    }),
                });

                if (!vercelProjectResponse.ok) {
                    const errorData = await vercelProjectResponse.json();
                    console.error('Vercel API Error (Create Project):', errorData);
                    throw new Error(`Failed to create Vercel project: ${errorData.error?.message || vercelProjectResponse.statusText}`);
                }
                const vercelProjectData = await vercelProjectResponse.json();
                console.log('Vercel project created:', vercelProjectData.id, vercelProjectData.name);

                // --- Explicitly Trigger Vercel Deployment ---
                console.log(`Explicitly triggering deployment for Vercel project: ${vercelProjectData.id}`);
                const triggerDeploymentBody: VercelTriggerDeploymentBody = {
                    name: vercelProjectData.name, // Project name
                    gitSource: {
                        type: 'github',
                        repoId: repoData.id, // GitHub repo ID (numeric from GitHub API response)
                        ref: 'main',
                    },
                    target: 'production',
                };

                const triggerDeploymentResponse = await fetch(`https://api.vercel.com/v13/deployments${VERCEL_TEAM_ID ? `?teamId=${VERCEL_TEAM_ID}` : ''}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${VERCEL_TOKEN}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(triggerDeploymentBody),
                });

                if (!triggerDeploymentResponse.ok) {
                    const errorData = await triggerDeploymentResponse.json();
                    console.error('Vercel API Error (Trigger Deployment):', errorData);
                    throw new Error(`Failed to trigger Vercel deployment: ${errorData.error?.message || triggerDeploymentResponse.statusText}`);
                }
                const triggeredDeploymentData = await triggerDeploymentResponse.json();
                console.log('Vercel deployment triggered:', triggeredDeploymentData.id, triggeredDeploymentData.url);
                const specificDeploymentIdToPoll = triggeredDeploymentData.id; // Changed to const

                // --- Poll for Vercel deployment completion ---
                console.log(`Polling for Vercel deployment ID: ${specificDeploymentIdToPoll}`);
                let deploymentReady = false;
                let deploymentError = false;
                let finalDeploymentUrl = `https://${triggeredDeploymentData.url}`; // Initial URL from trigger response
                const maxRetries = 60;
                const retryInterval = 5000;

                for (let i = 0; i < maxRetries; i++) {
                    await new Promise(resolve => setTimeout(resolve, retryInterval));

                    // Poll the specific deployment ID
                    const deploymentStatusApiUrl = VERCEL_TEAM_ID
                        ? `https://api.vercel.com/v13/deployments/${specificDeploymentIdToPoll}?teamId=${VERCEL_TEAM_ID}`
                        : `https://api.vercel.com/v13/deployments/${specificDeploymentIdToPoll}`;

                    const deploymentStatusResponse = await fetch(deploymentStatusApiUrl, {
                        headers: { 'Authorization': `Bearer ${VERCEL_TOKEN}` },
                    });

                    if (!deploymentStatusResponse.ok) {
                        const errorData = await deploymentStatusResponse.json();
                        console.error('Vercel API Error (Get Deployment Status):', errorData);
                        continue;
                    }

                    const deploymentData = await deploymentStatusResponse.json();
                    console.log(`Vercel deployment ID ${deploymentData.id} state: ${deploymentData.readyState}, URL: ${deploymentData.url}`);

                    if (deploymentData.readyState === 'READY') {
                        deploymentReady = true;
                        finalDeploymentUrl = `https://${deploymentData.url}`; // Update with final URL if different
                        break;
                    } else if (deploymentData.readyState === 'ERROR' || deploymentData.readyState === 'CANCELED' || deploymentData.readyState === 'FAILED') {
                        deploymentError = true;
                        console.error('Vercel deployment failed or was canceled:', deploymentData.meta?.error || deploymentData.errorMessage || 'Unknown deployment error');
                        break;
                    }
                    console.log(`Polling attempt ${i + 1}/${maxRetries} complete for deployment ${specificDeploymentIdToPoll}.`);
                }

                if (!deploymentReady || deploymentError) {
                    throw new Error(deploymentError ? 'Vercel deployment failed or was canceled.' : 'Vercel deployment timed out.');
                }

                vercelProjectUrl = finalDeploymentUrl;

            } catch (vercelError: unknown) {
                console.error('Error during Vercel project creation or deployment polling:', (vercelError as Error).message);
                return NextResponse.json(
                    {
                        message: 'GitHub repository created and template pushed, but Vercel operation failed.',
                        repoName: repoData.name,
                        repoUrl: repoData.html_url,
                        error: `Vercel operation failed: ${(vercelError as Error).message}`
                    },
                    { status: 500 }
                );
            }

            fs.rmSync(tempRepoPath, { recursive: true, force: true });

            return NextResponse.json({
                message: 'Repository created, template pushed, and Vercel project deployed!',
                repoName: repoData.name,
                repoUrl: repoData.html_url,
                vercelUrl: vercelProjectUrl,
            });

        } catch (gitOpsError: unknown) {
            let errorMessage = 'Unknown error during git operations or file copying.';
            if (gitOpsError instanceof Error) {
                errorMessage = gitOpsError.message;
            }
            console.error('Error during git operations or file copying:', errorMessage);
            if (typeof gitOpsError === 'object' && gitOpsError !== null) {
                const execError = gitOpsError as ExecException & { stdout?: Buffer; stderr?: Buffer };
                if (execError.stdout) {
                    console.error('STDOUT:', execError.stdout.toString());
                }
                if (execError.stderr) {
                    console.error('STDERR:', execError.stderr.toString());
                }
            }

            if (fs.existsSync(tempRepoPath)) {
                fs.rmSync(tempRepoPath, { recursive: true, force: true });
            }
            return NextResponse.json(
                { error: `Failed to push template to GitHub: ${errorMessage}. Repository was created (${repoData.html_url}) but might be empty or incomplete.` },
                { status: 500 }
            );
        }

    } catch (error: unknown) {
        let outerErrorMessage = 'Error creating GitHub repository';
        if (error instanceof Error) {
            outerErrorMessage = error.message;
        }
        console.error('Error creating GitHub repository (outer try):', outerErrorMessage);
        return NextResponse.json(
            { error: `Error creating GitHub repository: ${outerErrorMessage}` },
            { status: 500 }
        );
    }
} 