import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { execSync, ExecException } from 'child_process';

export async function POST() {
    const { GITHUB_TOKEN, GITHUB_USERNAME } = process.env;

    if (!GITHUB_TOKEN || !GITHUB_USERNAME) {
        return NextResponse.json(
            { error: 'GitHub token or username not configured.' },
            { status: 500 }
        );
    }

    const repoNameBase = `miniapp`; // We can make this configurable later from prompt
    const repoName = `${repoNameBase}-${Date.now()}`;

    try {
        const createRepoResponse = await fetch('https://api.github.com/user/repos', {
            method: 'POST',
            headers: {
                Authorization: `token ${GITHUB_TOKEN}`,
                Accept: 'application/vnd.github.v3+json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                name: repoName,
                private: false, // Public repository
                description: 'A new miniapp generated by WeeApp',
            }),
        });

        if (!createRepoResponse.ok) {
            const errorData = await createRepoResponse.json();
            console.error('GitHub API Error (Create Repo):', errorData);
            return NextResponse.json(
                { error: `Failed to create GitHub repository: ${errorData.message || createRepoResponse.statusText}` },
                { status: createRepoResponse.status }
            );
        }

        const repoData = await createRepoResponse.json();

        // Paths
        const templatePath = path.resolve(process.cwd(), 'internal_template');
        const tempBaseDir = path.join('/tmp', 'weeapp-processing'); // Use Vercel's writable /tmp directory
        const tempRepoPath = path.join(tempBaseDir, repoData.name);

        try {
            // 1. Ensure .tmp directory exists
            if (!fs.existsSync(tempBaseDir)) {
                fs.mkdirSync(tempBaseDir, { recursive: true });
            }
            // 2. Clean up if tempRepoPath already exists (e.g. from a failed previous attempt)
            if (fs.existsSync(tempRepoPath)) {
                fs.rmSync(tempRepoPath, { recursive: true, force: true });
            }
            // 3. Create the temporary directory for the new repo content
            fs.mkdirSync(tempRepoPath, { recursive: true });

            // 4. Copy template files (cp -a preserves attributes and copies recursively, including dotfiles)
            execSync(`cp -a "${templatePath}/." "${tempRepoPath}/"`, { stdio: 'pipe' });

            // 5. Remove existing .git directory from template if it exists
            const templateGitDir = path.join(tempRepoPath, '.git');
            if (fs.existsSync(templateGitDir)) {
                fs.rmSync(templateGitDir, { recursive: true, force: true });
            }

            // 6. Git operations
            const gitUserEmail = `${GITHUB_USERNAME}@users.noreply.github.com`;
            const remoteUrl = `https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com/${GITHUB_USERNAME}/${repoData.name}.git`;

            const gitCommands = [
                'git init -b main',
                `git config user.name "${GITHUB_USERNAME}"`, // Or a generic app name
                `git config user.email "${gitUserEmail}"`,
                'git add .',
                'git commit -m "Initial commit: Farcaster miniapp template by WeeApp"',
                `git remote add origin ${remoteUrl}`,
                'git push -u origin main'
            ];

            for (const cmd of gitCommands) {
                console.log(`Executing: ${cmd} in ${tempRepoPath}`); // For debugging
                execSync(cmd, { cwd: tempRepoPath, stdio: 'pipe' }); // Use 'pipe' to avoid token leakage to server logs if git prints full remote URL
            }

            // 7. Cleanup temporary directory
            fs.rmSync(tempRepoPath, { recursive: true, force: true });

            return NextResponse.json({
                message: 'Repository created and template pushed successfully!',
                repoName: repoData.name,
                repoUrl: repoData.html_url,
            });

        } catch (gitOpsError: unknown) {
            let errorMessage = 'Unknown error during git operations or file copying.';
            if (gitOpsError instanceof Error) {
                errorMessage = gitOpsError.message;
            }
            console.error('Error during git operations or file copying:', errorMessage);
            // Check if it's an ExecException which might have stdout/stderr
            if (typeof gitOpsError === 'object' && gitOpsError !== null) {
                const execError = gitOpsError as ExecException & { stdout?: Buffer; stderr?: Buffer };
                if (execError.stdout) {
                    console.error('STDOUT:', execError.stdout.toString());
                }
                if (execError.stderr) {
                    console.error('STDERR:', execError.stderr.toString());
                }
            }

            // Attempt to clean up the temp directory on error too
            if (fs.existsSync(tempRepoPath)) {
                fs.rmSync(tempRepoPath, { recursive: true, force: true });
            }
            // We might want to delete the GitHub repo if this part fails, but that adds complexity.
            return NextResponse.json(
                { error: `Failed to push template to GitHub: ${errorMessage}. Repository was created (${repoData.html_url}) but might be empty or incomplete.` },
                { status: 500 }
            );
        }

    } catch (error: unknown) {
        let outerErrorMessage = 'Error creating GitHub repository';
        if (error instanceof Error) {
            outerErrorMessage = error.message;
        }
        console.error('Error creating GitHub repository (outer try):', outerErrorMessage);
        return NextResponse.json(
            { error: `Error creating GitHub repository: ${outerErrorMessage}` },
            { status: 500 }
        );
    }
} 