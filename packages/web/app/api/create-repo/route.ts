import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { execSync, ExecException } from 'child_process';

// Helper function copyDirRecursiveSync removed

export async function POST() {
    const { GITHUB_TOKEN, GITHUB_USERNAME } = process.env;

    if (!GITHUB_TOKEN || !GITHUB_USERNAME) {
        return NextResponse.json(
            { error: 'GitHub token or username not configured.' },
            { status: 500 }
        );
    }

    const repoNameBase = `miniapp`;
    const repoName = `${repoNameBase}-${Date.now()}`;

    try {
        const createRepoResponse = await fetch('https://api.github.com/user/repos', {
            method: 'POST',
            headers: {
                Authorization: `token ${GITHUB_TOKEN}`,
                Accept: 'application/vnd.github.v3+json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                name: repoName,
                private: false,
                description: 'A new miniapp generated by WeeApp',
            }),
        });

        if (!createRepoResponse.ok) {
            const errorData = await createRepoResponse.json();
            console.error('GitHub API Error (Create Repo):', errorData);
            return NextResponse.json(
                { error: `Failed to create GitHub repository: ${errorData.message || createRepoResponse.statusText}` },
                { status: createRepoResponse.status }
            );
        }

        const repoData = await createRepoResponse.json();

        const templatePath = path.resolve(process.cwd(), 'template');
        const tempBaseDir = path.join('/tmp', 'weeapp-processing');
        const tempRepoPath = path.join(tempBaseDir, repoData.name);

        try {
            if (!fs.existsSync(tempBaseDir)) {
                fs.mkdirSync(tempBaseDir, { recursive: true });
            }
            if (fs.existsSync(tempRepoPath)) {
                fs.rmSync(tempRepoPath, { recursive: true, force: true });
            }
            fs.mkdirSync(tempRepoPath, { recursive: true });

            console.log(`Copying template from ${templatePath} to ${tempRepoPath} using cp -a...`);
            // 4. Copy template files using cp -a
            execSync(`cp -a "${templatePath}/." "${tempRepoPath}/"`, { stdio: 'pipe' });

            console.log('Listing contents of tempRepoPath after cp -a:');
            try {
                const filesInTemp = execSync('ls -la', { cwd: tempRepoPath, stdio: 'pipe' }).toString();
                console.log(filesInTemp);
            } catch (lsError: unknown) {
                console.error('Error listing files in tempRepoPath:', (lsError as Error).message);
            }

            const templateGitignorePath = path.join(tempRepoPath, '.gitignore');
            if (fs.existsSync(templateGitignorePath)) {
                try {
                    const gitignoreContent = fs.readFileSync(templateGitignorePath, 'utf8');
                    console.log('Content of .gitignore in template:');
                    console.log(gitignoreContent);
                } catch (readError: unknown) {
                    console.error('Error reading .gitignore in template:', (readError as Error).message);
                }
            } else {
                console.log('No .gitignore file found at the root of the copied template.');
            }

            const templateGitDir = path.join(tempRepoPath, '.git');
            if (fs.existsSync(templateGitDir)) {
                fs.rmSync(templateGitDir, { recursive: true, force: true });
            }

            const gitUserEmail = `${GITHUB_USERNAME}@users.noreply.github.com`;
            const remoteUrl = `https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com/${GITHUB_USERNAME}/${repoData.name}.git`;

            const execOptions = {
                cwd: tempRepoPath,
                stdio: 'pipe' as const,
                env: {
                    ...process.env,
                    GIT_AUTHOR_NAME: GITHUB_USERNAME,
                    GIT_AUTHOR_EMAIL: gitUserEmail,
                    GIT_COMMITTER_NAME: GITHUB_USERNAME,
                    GIT_COMMITTER_EMAIL: gitUserEmail,
                }
            };

            console.log(`Initializing Git repository in ${tempRepoPath}`);
            execSync('git init -b main', execOptions);

            console.log('Adding files to Git...');
            execSync('git add .', execOptions);

            console.log('Checking git status...');
            const statusOutput = execSync('git status --porcelain', execOptions).toString().trim();
            let commitMade = false;

            if (!statusOutput) {
                console.warn('No changes to commit. Template might be empty or all files are gitignored. Repository will be created empty.');
            } else {
                console.log('Committing files...');
                execSync('git commit -m "Initial commit: Farcaster miniapp template by WeeApp"', execOptions);
                commitMade = true;
            }

            if (commitMade) {
                console.log(`Adding remote origin: ${repoData.html_url}`);
                execSync(`git remote add origin ${remoteUrl}`, execOptions);
                console.log('Pushing to GitHub...');
                execSync('git push -u origin main', execOptions);
            } else {
                console.log('Skipping push as no commits were made.');
            }

            fs.rmSync(tempRepoPath, { recursive: true, force: true });

            return NextResponse.json({
                message: 'Repository created and template pushed successfully!',
                repoName: repoData.name,
                repoUrl: repoData.html_url,
            });

        } catch (gitOpsError: unknown) {
            let errorMessage = 'Unknown error during git operations or file copying.';
            if (gitOpsError instanceof Error) {
                errorMessage = gitOpsError.message;
            }
            console.error('Error during git operations or file copying:', errorMessage);
            if (typeof gitOpsError === 'object' && gitOpsError !== null) {
                const execError = gitOpsError as ExecException & { stdout?: Buffer; stderr?: Buffer };
                if (execError.stdout) {
                    console.error('STDOUT:', execError.stdout.toString());
                }
                if (execError.stderr) {
                    console.error('STDERR:', execError.stderr.toString());
                }
            }

            if (fs.existsSync(tempRepoPath)) {
                fs.rmSync(tempRepoPath, { recursive: true, force: true });
            }
            return NextResponse.json(
                { error: `Failed to push template to GitHub: ${errorMessage}. Repository was created (${repoData.html_url}) but might be empty or incomplete.` },
                { status: 500 }
            );
        }

    } catch (error: unknown) {
        let outerErrorMessage = 'Error creating GitHub repository';
        if (error instanceof Error) {
            outerErrorMessage = error.message;
        }
        console.error('Error creating GitHub repository (outer try):', outerErrorMessage);
        return NextResponse.json(
            { error: `Error creating GitHub repository: ${outerErrorMessage}` },
            { status: 500 }
        );
    }
} 